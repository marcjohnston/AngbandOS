using AngbandOS.Core.Interface;
using System.Reflection;
using System.Text.RegularExpressions;

const string FOREIGNCOLLECTIONNAMETAGNAME = "foreign-collection-name";
const string TITLETAGNAME = "title";
const string CATEGORYTITLETAGNAME = "category-title";
const string ENTITYNOUNTAGNAME = "entity-noun";
const string ENTITYNOUNTITLETAGNAME = "entity-noun-title";
const string ENTITYNAMEPROPERTYNAMETAGNAME = "entity-name-property-name";
const string ENTITYKEYPROPERTYNAMETAGNAME = "entity-key-property-name";
const string SUMMARYTAGNAME = "summary";
const string RETURNSTAGNAME = "returns";

if (args.Length < 2)
{
    Console.WriteLine("syntax: scaffold-metadata {configuration_file} {output_folder}");
    Console.WriteLine("where:");
    Console.WriteLine(@"    configuration_file - full path, file name and extension to the top-level game configuration file (e.g. AngbandOS\AngbandOS.Core.Interface.Configuration\GameConfiguration.cs)");
    Console.WriteLine(@"    output_folder - full path to the folder to output the metadata classes (e.g. AngbandOS\AngbandOS.Core.Interface.Metadata\Scaffolded");
    Environment.Exit(1); // Invalid arguments.
}

string configurationName = args[0]; // TODO: no detection
string outputFolder = args[1]; // TODO: no detection

string? folder = Path.GetDirectoryName(configurationName); // TODO: no null detection
string? filename = Path.GetFileNameWithoutExtension(configurationName); // TODO: no null detection

// We need to cache the ParseClass method because it can be called numerous times.
Dictionary<string, (ClassPropertyMetadata, PropertyMetadata[])> classPropertyMetadataDictionary = new Dictionary<string, (ClassPropertyMetadata, PropertyMetadata[])>();

// Parse the top-level game configuration file that was supplied on the command line.
(ClassPropertyMetadata _, PropertyMetadata[] gameConfigurationPropertyMetadatas) = ParseClass(configurationName);
WriteClass(outputFolder, filename, gameConfigurationPropertyMetadatas);

void WriteClass(string folder, string entityName, PropertyMetadata[] propertyMetadatas)
{
    string filename = Path.Combine(folder, $"{entityName}Metadata.cs");
    using (StreamWriter writer = new StreamWriter(filename, false))
    {
        writer.WriteLine($"// <auto-generated>");
        writer.WriteLine($"// This code was generated by {Assembly.GetExecutingAssembly().GetName().Name}.");
        writer.WriteLine($"// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.");
        writer.WriteLine($"// </auto-generated>");
        writer.WriteLine($"namespace AngbandOS.Core.Interface.Metadata;");
        writer.WriteLine();
        writer.WriteLine($"public static class {entityName}Metadata");
        writer.WriteLine(@"{");
        writer.WriteLine($"    public static PropertyMetadata[] Metadata");
        writer.WriteLine(@"    {");
        writer.WriteLine($"        get");
        writer.WriteLine(@"        {");
        writer.WriteLine($"            return new PropertyMetadata[]");
        writer.WriteLine(@"            {");

        foreach (PropertyMetadata genericPropertyMetadata in propertyMetadatas)
        {
            WriteProperty(writer, folder, genericPropertyMetadata, 4);
        }
        writer.WriteLine(@"            };");
        writer.WriteLine(@"        }");
        writer.WriteLine(@"    }");
        writer.WriteLine(@"}");
    }
}

string WriteNullableStringValue(string? value) => value == null ? "null" : $"\"{value}\"";
string WriteNullableStringsValue(string[]? value) => value == null ? "null" : $"\"{value}\"";
string WriteNullableIntegerValue(int? value) => !value.HasValue ? "null" : $"{value.Value}";
string WriteNullableBooleanValue(bool? value) => !value.HasValue ? "null" : $"{value.Value.ToString().ToLower()}";
string WriteNullableCharacterValue(char? value) => !value.HasValue ? "null" : $"\"{value.Value}\"";
string WriteNullableColorValue(ColorEnum? value) => !value.HasValue ? "null" : $"ColorEnum.{value.Value}";

void WriteProperty(StreamWriter writer, string folder, PropertyMetadata genericPropertyMetadata, int indentUnits)
{
    string indentation = new string(' ', indentUnits * 4);
    switch (genericPropertyMetadata)
    {
        case IntegerPropertyMetadata genericIntegerPropertyMetadata:
            writer.WriteLine($"{indentation}new IntegerPropertyMetadata(\"{genericIntegerPropertyMetadata.PropertyName}\")");
            writer.WriteLine($"{indentation}{{");
            writer.WriteLine($"{indentation}    {nameof(genericIntegerPropertyMetadata.DefaultValue)} = {WriteNullableIntegerValue(genericIntegerPropertyMetadata.DefaultValue)},");
            break;
        case BooleanPropertyMetadata genericBooleanPropertyMetadata:
            writer.WriteLine($"{indentation}new BooleanPropertyMetadata(\"{genericBooleanPropertyMetadata.PropertyName}\")");
            writer.WriteLine($"{indentation}{{");
            writer.WriteLine($"{indentation}    {nameof(genericBooleanPropertyMetadata.DefaultValue)} = {WriteNullableBooleanValue(genericBooleanPropertyMetadata.DefaultValue)},");
            break;
        case StringPropertyMetadata genericStringPropertyMetadata:
            writer.WriteLine($"{indentation}new StringPropertyMetadata(\"{genericStringPropertyMetadata.PropertyName}\")");
            writer.WriteLine($"{indentation}{{");
            writer.WriteLine($"{indentation}    {nameof(genericStringPropertyMetadata.DefaultValue)} = {WriteNullableStringValue(genericStringPropertyMetadata.DefaultValue)},");
            break;
        case StringsPropertyMetadata genericStringArrayPropertyMetadata:
            writer.WriteLine($"{indentation}new StringsPropertyMetadata(\"{genericStringArrayPropertyMetadata.PropertyName}\")");
            writer.WriteLine($"{indentation}{{");
            writer.WriteLine($"{indentation}    {nameof(genericStringArrayPropertyMetadata.DefaultValue)} = {WriteNullableStringsValue(genericStringArrayPropertyMetadata.DefaultValue)},");
            break;
        case ForeignKeyPropertyMetadata genericForeignKeyPropertyMetadata:
            writer.WriteLine($"{indentation}new ForeignKeyPropertyMetadata(\"{genericForeignKeyPropertyMetadata.PropertyName}\")");
            writer.WriteLine($"{indentation}{{");
            writer.WriteLine($"{indentation}    ForeignCollectionName = \"{genericForeignKeyPropertyMetadata.ForeignCollectionName}\",");
            break;
        case ForeignKeysPropertyMetadata genericForeignKeysPropertyMetadata:
            writer.WriteLine($"{indentation}new ForeignKeysPropertyMetadata(\"{genericForeignKeysPropertyMetadata.PropertyName}\")");
            writer.WriteLine($"{indentation}{{");
            writer.WriteLine($"{indentation}    ForeignCollectionName = \"{genericForeignKeysPropertyMetadata.ForeignCollectionName}\",");
            break;
        case CharacterPropertyMetadata genericCharacterPropertyMetadata:
            writer.WriteLine($"{indentation}new CharacterPropertyMetadata(\"{genericCharacterPropertyMetadata.PropertyName}\")");
            writer.WriteLine($"{indentation}{{");
            writer.WriteLine($"{indentation}    {nameof(genericCharacterPropertyMetadata.DefaultValue)} = {WriteNullableCharacterValue(genericCharacterPropertyMetadata.DefaultValue)},");
            break;
        case ColorPropertyMetadata genericColorEnumPropertyMetadata:
            writer.WriteLine($"{indentation}new ColorPropertyMetadata(\"{genericColorEnumPropertyMetadata.PropertyName}\")");
            writer.WriteLine($"{indentation}{{");
            writer.WriteLine($"{indentation}    {nameof(genericColorEnumPropertyMetadata.DefaultValue)} = {WriteNullableColorValue(genericColorEnumPropertyMetadata.DefaultValue)},");
            break;
        case CollectionPropertyMetadata genericCollectionArrayPropertyMetadata:
            writer.WriteLine($"{indentation}new CollectionPropertyMetadata(\"{genericCollectionArrayPropertyMetadata.PropertyName}\")");
            writer.WriteLine($"{indentation}{{");
            writer.WriteLine($"{indentation}    {nameof(genericCollectionArrayPropertyMetadata.PropertyMetadatas)} = {genericCollectionArrayPropertyMetadata.EntityNoun}Metadata.Metadata,");
            writer.WriteLine($"{indentation}    {nameof(genericCollectionArrayPropertyMetadata.EntityNounTitle)} = \"{genericCollectionArrayPropertyMetadata.EntityNounTitle}\",");
            writer.WriteLine($"{indentation}    {nameof(genericCollectionArrayPropertyMetadata.EntityNoun)} = \"{genericCollectionArrayPropertyMetadata.EntityNoun}\",");
            writer.WriteLine($"{indentation}    {nameof(genericCollectionArrayPropertyMetadata.EntityNamePropertyName)} = {WriteNullableStringValue(genericCollectionArrayPropertyMetadata.EntityNamePropertyName)},");
            writer.WriteLine($"{indentation}    {nameof(genericCollectionArrayPropertyMetadata.EntityKeyPropertyName)} = \"{genericCollectionArrayPropertyMetadata.EntityKeyPropertyName}\",");
            WriteClass(folder, genericCollectionArrayPropertyMetadata.EntityNoun, genericCollectionArrayPropertyMetadata.PropertyMetadatas);
            break;
        case TuplePropertyMetadata genericTupleArrayPropertyMetadata:
            writer.WriteLine($"{indentation}new TuplePropertyMetadata(\"{genericTupleArrayPropertyMetadata.PropertyName}\")");
            writer.WriteLine($"{indentation}{{");
            writer.WriteLine($"{indentation}    {nameof(genericTupleArrayPropertyMetadata.Types)} = new PropertyMetadata[]");
            writer.WriteLine($"{indentation}    {{");
            foreach (PropertyMetadata tuplePropertyMetadata in genericTupleArrayPropertyMetadata.Types)
            {
                WriteProperty(writer, folder, tuplePropertyMetadata, indentUnits + 2);
            }
            writer.WriteLine($"{indentation}    }},");
            break;       
        default:
            throw new Exception($"{genericPropertyMetadata.GetType().Name} not supported.");
    }

    writer.WriteLine($"{indentation}    {nameof(genericPropertyMetadata.Description)} = \"{genericPropertyMetadata.Description.Replace("\"", "\\\"")}\",");
    writer.WriteLine($"{indentation}    {nameof(genericPropertyMetadata.IsNullable)} = {genericPropertyMetadata.IsNullable.ToString().ToLower()},");
    if (genericPropertyMetadata.Title != null)
    {
        writer.WriteLine($"{indentation}    {nameof(genericPropertyMetadata.Title)} = \"{genericPropertyMetadata.Title}\",");
    }
    if (genericPropertyMetadata.CategoryTitle != null)
    {
        writer.WriteLine($"{indentation}    {nameof(genericPropertyMetadata.CategoryTitle)} = \"{genericPropertyMetadata.CategoryTitle}\",");
    }
    writer.WriteLine($"{indentation}}},");
}

string? RetrieveTupleComment(IEnumerable<string> commentList, string tuplePropertyName, string propertyName)
{
    // Find the description for the tuple in the returns XML comments.
    string prefix = $"{tuplePropertyName}:{propertyName}:".ToLower();
    string? matchingComment = commentList.SingleOrDefault(_description => _description.ToLower().StartsWith(prefix)); // TODO: Detect multiple matches and throw error.
    if (matchingComment != null)
    {
        return matchingComment.Substring(prefix.Length).Trim();
    }
    return null;
}

string? ConvertToTitleCase(string? value) => value == null ? null : Regex.Replace(value, "(?<!^)([A-Z])", " $1");

(ClassPropertyMetadata classLevelPropertyMetadata, PropertyMetadata[] propertyLevelPropertyMetadata) ParseClass(string classFilename)
{
    // Detect if we have already processed this file.
    if (classPropertyMetadataDictionary.TryGetValue(classFilename, out (ClassPropertyMetadata, PropertyMetadata[]) cachedResults))
    {
        // We did, return the results.
        return cachedResults;
    }

    List<PropertyMetadata> propertyMetadatas = new List<PropertyMetadata>(); // Mutable work-in-progress list of output results.
    string[] text = File.ReadAllLines(classFilename);

    // Class level variables.  These may be overridden by property level variables.
    string? classEntityNamePropertyName = null;

    // Property level variables.  These are reset by the ResetPropertyXMLComments method.
    Dictionary<string, List<string>> metadataDictionary = new Dictionary<string, List<string>>();
    string? currentMultilineTag = null;
    (string, bool)[] supportedTags = new (string, bool)[]
    {
        (FOREIGNCOLLECTIONNAMETAGNAME, false),
        (TITLETAGNAME, false),
        (CATEGORYTITLETAGNAME, false),
        (ENTITYNOUNTAGNAME, false),
        (ENTITYNOUNTITLETAGNAME, false),
        (ENTITYNAMEPROPERTYNAMETAGNAME, false),
        (ENTITYKEYPROPERTYNAMETAGNAME, false),
        (SUMMARYTAGNAME, true),
        (RETURNSTAGNAME, true),
    };
    ResetPropertyXMLComments();

    void ResetPropertyXMLComments()
    {
        // The property that we are parsing will be changing.  We need to clear all of the values that we recorded for this property.
        metadataDictionary.Clear();
        metadataDictionary.Clear();
        foreach ((string tagName, bool multiline) in supportedTags)
        {
            metadataDictionary.Add(tagName, new List<string>());
        }
    }

    string? GetSinglelineMetadataValue(string tagName)
    {
        return metadataDictionary[tagName].Count == 0 ? null : metadataDictionary[tagName][0];
    }

    // Parse every line in the c# file.
    foreach (string line in text)
    {
        // Convert the line to lowercase for easier detection of the XML tags.  We are not supporting case-sensitive XML tags.
        string trimmedLine = line.Trim();

        // Process all of the XML tags.
        if (trimmedLine.StartsWith(@"///"))
        {
            // Check to see if we are currently processing a multiline tag.
            if (currentMultilineTag != null)
            {
                // We are currently processing a multiline tag.  Check for the closing tag.
                int endPos = trimmedLine.IndexOf($"</{currentMultilineTag}>");
                if (endPos >= 0)
                {
                    // This is the ending tag.
                    currentMultilineTag = null;
                }
                else
                {
                    // Add the line to the metadata but skip blank lines.
                    metadataDictionary[currentMultilineTag].Add(trimmedLine.Substring(3).Trim());
                }
            }
            else
            {
                // We are not currently processing a multiline tag.  Check to see if any of the known tags are found.
                foreach (KeyValuePair<string, List<string>> metadataNameAndValue in metadataDictionary)
                {
                    int startPos = trimmedLine.IndexOf($"<{metadataNameAndValue.Key}>");
                    if (startPos >= 0)
                    {
                        // Yes, the starting tag was found.  Check to see if this is a single line with the presense of the closing tag.
                        int endPos = trimmedLine.IndexOf($"</{metadataNameAndValue.Key}>");
                        if (endPos >= 0)
                        {
                            // Yes, this is a single line tag.
                            string value = trimmedLine.Substring(startPos + metadataNameAndValue.Key.Length + 2, endPos - startPos - metadataNameAndValue.Key.Length - 2);
                            metadataDictionary[metadataNameAndValue.Key].Add(value);
                        }
                        else
                        {
                            // This is the start of a multiline tag.
                            currentMultilineTag = metadataNameAndValue.Key;
                        }
                    }
                }
            }
        }
        else
        {
            // Validate XML tags do not have too many lines.
            foreach ((string tagName, bool multiline) in supportedTags)
            {
                if (!multiline && metadataDictionary[tagName].Count > 1)
                {
                    throw new Exception($"XML tag {tagName} cannot have more than one XML comment line found in file {classFilename}.");
                }
            }

            // This line of code is not an XML tag.  Split the line into tokens so that we can continue detection.
            string[] tokens = trimmedLine.Split(' ');

            // Check to see if this line represents the class.
            int classIndex = Array.IndexOf(tokens, "class");
            if (classIndex >= 0)
            {
                // Ensure this file matches the class we are expecting to parse.
                string className = tokens[classIndex + 1];
                if (className != Path.GetFileNameWithoutExtension(classFilename))
                {
                    throw new Exception($"The file {classFilename} does not contain the expected class {className}.");
                }

                // Retrieve class level property values.
                classEntityNamePropertyName = GetSinglelineMetadataValue("entity-name-property-name");

                // Reset the property level XML comments.
                ResetPropertyXMLComments();
            }
            // Is this a public property.
            else if (tokens.Length > 1 && tokens[0] == "public")
            {
                // Yes.  Check if there is a default value specified.
                string? defaultValueParsedString = null;
                int tokenIndex = Array.IndexOf(tokens, "=");
                if (tokenIndex >= 0)
                {
                    // Extract the default value and remove the semi-colon.
                    defaultValueParsedString = String.Join(" ", tokens.Skip(tokenIndex + 1).Take(tokens.Length - tokenIndex)).Replace(";", "");

                    int commentPosition = defaultValueParsedString.IndexOf(@"//");
                    if (commentPosition >= 0)
                    {
                        defaultValueParsedString = defaultValueParsedString.Substring(0, commentPosition);
                    }

                    // Back off the { get; set; } tokens.
                    tokenIndex -= 5;
                }
                else
                {
                    // Find the } in the { get; set; } and back up 4 tokens.
                    tokenIndex = Array.IndexOf(tokens, "}") - 4;
                }

                // Get the name of the property.
                string name = tokens[tokenIndex];

                // Check if the virtual keyword was specified.
                int leadingTokensToSkip = 1; // Skip the public keyword.
                if (tokens[1] == "virtual")
                {
                    leadingTokensToSkip++; // Skip the virtual keyword.
                }

                string fullDataType = String.Join(" ", tokens.Skip(leadingTokensToSkip).Take(tokenIndex - leadingTokensToSkip));
                (string dataType, bool isNullable, bool isArray) = ParseDataType(fullDataType);
                string description = String.Join(' ', metadataDictionary[SUMMARYTAGNAME]);

                // Detect a tuple
                if (dataType.StartsWith("("))
                {
                    // Ensure it is properly enclosed in parenthesis
                    if (!dataType.EndsWith(")"))
                    {
                        string message = $"The {name} property in the {classFilename} file has a tuple data type of {dataType} that does not have a trailing end parenthesis ).";
                        Console.WriteLine(message);
                        throw new Exception(message);
                    }

                    // Remove the parenthesis.
                    dataType = dataType.Substring(1, dataType.Length - 2);

                    // Separate each tuple data type into a token.
                    string[] tupleDataTypeTokens = dataType.Split(",");

                    // Generate property metadata for each token.
                    List<PropertyMetadata> tuplePropertyMetadatasList = new List<PropertyMetadata>();
                    foreach (string tupleDataTypeToken in tupleDataTypeTokens)
                    {
                        // Check to see if there is a name for this tuple.
                        string[] dataTypeAndNameTokens = tupleDataTypeToken.Trim().Split(" ");

                        (string tupleDataType, bool tupleIsNullable, bool tupleIsArray) = ParseDataType(dataTypeAndNameTokens[0]);

                        string tupleName = ""; // There is no default for a name.  Names are required.
                        string? tupleTitle = null; // Titles are not required.
                        string tupleDescription = ""; // There is no default for a description.  Descriptions are required.
                        string? tupleForeignCollectionName = null; // Foreign-collection-names are not required.

                        // Check to see if a name was provided.
                        if (dataTypeAndNameTokens.Length > 1)
                        {
                            tupleName = dataTypeAndNameTokens[1];
                            tupleDescription = RetrieveTupleComment(metadataDictionary[RETURNSTAGNAME], tupleName, description) ?? "";
                            tupleTitle = RetrieveTupleComment(metadataDictionary[RETURNSTAGNAME], tupleName, TITLETAGNAME);
                            tupleForeignCollectionName = RetrieveTupleComment(metadataDictionary[RETURNSTAGNAME], tupleName, FOREIGNCOLLECTIONNAMETAGNAME);
                        }

                        PropertyMetadata? propertyMetadata = GetPropertyMetadata(
                            classFilename, 
                            tupleDataType, 
                            tupleName, 
                            "", // Tuples do not support categories.
                            tupleDescription, 
                            tupleIsNullable, 
                            tupleIsArray, 
                            tupleTitle, 
                            defaultValueParsedString, 
                            tupleForeignCollectionName);
                        if (propertyMetadata == null)
                        {
                            throw new Exception($"The {name} property in the {classFilename} file has a data type of {dataType} that is not supported.");
                        }
                        tuplePropertyMetadatasList.Add(propertyMetadata);
                    }
                    propertyMetadatas.Add(new TuplePropertyMetadata(name)
                    {
                        CategoryTitle = GetSinglelineMetadataValue(CATEGORYTITLETAGNAME) ?? "",
                        Description = description,
                        IsNullable = isNullable,
                        Title = GetSinglelineMetadataValue(TITLETAGNAME) ?? ConvertToTitleCase(name),
                        Types = tuplePropertyMetadatasList.ToArray(),
                    });
                }
                else
                {
                    // Detect a collection.  Collections always have a suffix of GameConfiguration.
                    if (dataType.EndsWith("GameConfiguration"))
                    {
                        // The entity name defaults as the prefix of the class name.
                        string entityNoun = GetSinglelineMetadataValue(ENTITYNOUNTAGNAME) ?? dataType.Substring(0, dataType.Length - 17);

                        (PropertyMetadata collectionClassLevelPropertyMetadata, PropertyMetadata[] collectionPropertyLevelPropertyMetadata) = ParseClass(Path.Combine(Path.GetDirectoryName(classFilename), $"{dataType}.cs"));
                        propertyMetadatas.Add(new CollectionPropertyMetadata(name)
                        {
                            CategoryTitle = GetSinglelineMetadataValue(CATEGORYTITLETAGNAME) ?? "",
                            Description = description,
                            IsNullable = isNullable,
                            Title = GetSinglelineMetadataValue(TITLETAGNAME) ?? ConvertToTitleCase(name),
                            EntityNounTitle = GetSinglelineMetadataValue(ENTITYNOUNTITLETAGNAME) ?? ConvertToTitleCase(entityNoun),
                            EntityNoun = entityNoun,
                            EntityKeyPropertyName = GetSinglelineMetadataValue(ENTITYKEYPROPERTYNAMETAGNAME) ?? "Key", // Provide a default.
                            EntityNamePropertyName = collectionClassLevelPropertyMetadata.EntityNamePropertyName ?? GetSinglelineMetadataValue(ENTITYNAMEPROPERTYNAMETAGNAME),
                            PropertyMetadatas = collectionPropertyLevelPropertyMetadata,
                        });
                    }
                    else
                    {
                        // This is not a tuple and it is not a collection.  Process it as a basic data type.
                        PropertyMetadata? propertyMetadata = GetPropertyMetadata(
                            classFilename, 
                            dataType, 
                            name, 
                            GetSinglelineMetadataValue(CATEGORYTITLETAGNAME) ?? "", 
                            description, 
                            isNullable, 
                            isArray,
                            GetSinglelineMetadataValue(TITLETAGNAME) ?? ConvertToTitleCase(name), 
                            defaultValueParsedString,
                            GetSinglelineMetadataValue(FOREIGNCOLLECTIONNAMETAGNAME));
                        if (propertyMetadata == null)
                        {
                            throw new Exception($"The {name} property in the {classFilename} file has a data type of {dataType} that is not supported.");
                        }
                        propertyMetadatas.Add(propertyMetadata);
                    }

                }

                // Reset the property level XML comments.
                ResetPropertyXMLComments();
            }
        }
    }

    ClassPropertyMetadata classLevelPropertyMetadata = new ClassPropertyMetadata()
    {
        EntityNamePropertyName = classEntityNamePropertyName
    };

    // Generate the results.
    (ClassPropertyMetadata, PropertyMetadata[]) results = (classLevelPropertyMetadata, propertyMetadatas.ToArray());

    // Store the results if the file is subject to be reparsed.
    classPropertyMetadataDictionary.Add(classFilename, results);

    // Return the results.
    return results;
}

///
(string dataType, bool isNullable, bool isArray) ParseDataType(string fullDataType)
{
    bool isNullable = false;
    bool isArray = false;
    if (fullDataType.EndsWith(@"?"))
    {
        fullDataType = fullDataType.Substring(0, fullDataType.Length - 1);
        isNullable = true;
    }
    if (fullDataType.EndsWith(@"[]"))
    {
        fullDataType = fullDataType.Substring(0, fullDataType.Length - 2);
        isArray = true;
    }
    return (fullDataType, isNullable, isArray);
}

PropertyMetadata? GetPropertyMetadata(string classFilename, string dataType, string name, string categoryTitle, string description, bool isNullable, bool isArray, string? title, string? defaultValueParsedString, string? foreignCollection)
{
    title = title ?? ConvertToTitleCase(name);
    switch (dataType)
    {
        case "char":
            return new CharacterPropertyMetadata(name)
            {
                CategoryTitle = categoryTitle,
                Description = description,
                IsNullable = isNullable,
                PropertyName = name,
                Title = title,
                DefaultValue = defaultValueParsedString == null || defaultValueParsedString == "null" ? null : Char.Parse(defaultValueParsedString)
            };
        case "bool":
            return new BooleanPropertyMetadata(name)
            {
                CategoryTitle = categoryTitle,
                Description = description,
                IsNullable = isNullable,
                Title = title,
                DefaultValue = defaultValueParsedString == null || defaultValueParsedString == "null" ? null : Boolean.Parse(defaultValueParsedString)
            };
        case "int":
            return new IntegerPropertyMetadata(name)
            {
                CategoryTitle = categoryTitle,
                Description = description,
                IsNullable = isNullable,
                Title = title,
                DefaultValue = defaultValueParsedString == null || defaultValueParsedString == "null" ? null : Int32.Parse(defaultValueParsedString)
            };
        case "ColorEnum":
            if (defaultValueParsedString != null && defaultValueParsedString != "null")
            {
                string[] colorEnumTokens = defaultValueParsedString.Split('.');
                if (colorEnumTokens.Length < 2 || colorEnumTokens[0] != "ColorEnum")
                {
                    throw new Exception($"The ColorEnum default value for the {name} property of the {classFilename} is not recognized.");
                }
                defaultValueParsedString = colorEnumTokens[1];
            }

            return new ColorPropertyMetadata(name)
            {
                CategoryTitle = categoryTitle,
                Description = description,
                IsNullable = isNullable,
                Title = title,
                DefaultValue = defaultValueParsedString == null || defaultValueParsedString == "null" ? null : Enum.Parse<ColorEnum>(defaultValueParsedString)
            };
        case "string":
            if (isArray)
            {
                if (foreignCollection != null)
                {
                    return new ForeignKeysPropertyMetadata(name)
                    {
                        CategoryTitle = categoryTitle,
                        Description = description,
                        IsNullable = isNullable,
                        Title = title,
                        ForeignCollectionName = foreignCollection
                    };
                }
                return new StringsPropertyMetadata(name)
                {
                    CategoryTitle = categoryTitle,
                    Description = description,
                    IsNullable = isNullable,
                    Title = title,
                    //DefaultValue = defaultValueParsedString == null || defaultValueParsedString == "null" ? null : defaultValueParsedString
                };
            }
            else
            {
                if (foreignCollection != null)
                {
                    return new ForeignKeyPropertyMetadata(name)
                    {
                        CategoryTitle = categoryTitle,
                        Description = description,
                        IsNullable = isNullable,
                        Title = title,
                        ForeignCollectionName = foreignCollection
                    };
                }
                return new StringPropertyMetadata(name)
                {
                    CategoryTitle = categoryTitle,
                    Description = description,
                    IsNullable = isNullable,
                    Title = title,
                    DefaultValue = defaultValueParsedString == null || defaultValueParsedString == "null" ? null : defaultValueParsedString.Substring(1, defaultValueParsedString.Length - 2)
                };
            }
        default:
            return null;
    }
}